//Bloco de Definições
#define WALL 25
#define BLACK 40
#define SILVER 70
#define REDMAX 53
#define REDMIN 50
#define OBJECT 25
#define SYNCMOTORS OUT_REGMODE_SPEED+OUT_REGMODE_SYNC

//Bloco de Variaveis
mutex mc;
bool Getted = false;
bool Rotate = false;
string state  = "Recharge";
int localCounter = 0;

//Maquina de Estado
void localMS(){
	switch(localCounter){
	    case 0:
		state = "Recharge";
		break;
	    case 1:
		state = "Stock";
		break;
	    case 2:
		state = "Warehouse";
		break;
	    case 3:
		state = "ExitWarehouse";
		break;
	    case 4:
		state = "Housing";
		break;
	    case 5:
		state = "Download";
		break;
	    case 6:
		state = "ExitHousing";
		break;
	    case 7:
		state = "SearchBase";
		break;
	    case 8:
		state = "SearchRecharge";
		break;
	    
	}
  
}

/* Função para contagem de ticks do NXT
1-Para uma revolução completa é necessario uma contagem de 180 ticks 2 pulsos por tick o que da 360 pulsos por revolução do eixo do motor
2-A frequência do NXT é de 1000Hz
*/
void DifferentialDriveKinematic(){
	long tf;
	long time;
	if(Getted == true){
		time = 1500;
	}else{
		time = 1000;
	}
	tf = CurrentTick() + time;
	while(CurrentTick() < tf);
	tf = 0;
}

//Funções para o robo girar no proprio eixo, andar e girar novamente no sentido oposto 
void TurnNinetyDegreesLeftPivoting(){
	//Curva
	Acquire(mc);
	OnFwdReg(OUT_B, 22, OUT_REGMODE_SYNC);
	OnFwdReg(OUT_C, 18, OUT_REGMODE_SYNC);
	DifferentialDriveKinematic();
    Off(OUT_BC);
	Release(mc);

	Acquire(mc);
	OnRevReg(OUT_B, 40, OUT_REGMODE_SPEED);
	OnFwdReg(OUT_C, 40, OUT_REGMODE_SPEED);
	DifferentialDriveKinematic();
    Off(OUT_BC);
	Release(mc);
	
	Acquire(mc);
	OnRevReg(OUT_B, 22, OUT_REGMODE_SYNC);
	OnRevReg(OUT_C, 18, OUT_REGMODE_SYNC);
	DifferentialDriveKinematic();
	Off(OUT_BC);
	OnRevReg(OUT_C, 40, OUT_REGMODE_SPEED);
	OnFwdReg(OUT_B, 40, OUT_REGMODE_SPEED);
	DifferentialDriveKinematic();
    Off(OUT_BC);
	Release(mc);
}

void TurnNinetyDegreesRightPivoting(){
    //Curva
	Acquire(mc);
	OnFwdReg(OUT_B, 22, OUT_REGMODE_SYNC);
	OnFwdReg(OUT_C, 18, OUT_REGMODE_SYNC);
	DifferentialDriveKinematic();
    Off(OUT_BC);
	Release(mc);

	Acquire(mc);
	OnRevReg(OUT_C, 40, OUT_REGMODE_SPEED);
	OnFwdReg(OUT_B, 40, OUT_REGMODE_SPEED);
	DifferentialDriveKinematic();
    Off(OUT_BC);
	Release(mc);
	
	Acquire(mc);
	OnRevReg(OUT_B, 22, OUT_REGMODE_SYNC);
	OnRevReg(OUT_C, 18, OUT_REGMODE_SYNC);
	DifferentialDriveKinematic();
	Off(OUT_BC);
	OnRevReg(OUT_B, 40, OUT_REGMODE_SPEED);
	OnFwdReg(OUT_C, 40, OUT_REGMODE_SPEED);
	DifferentialDriveKinematic();
    Off(OUT_BC);
	Release(mc);
}

//Função para o robo girar 180 graus no proprio eixo
void Turn180Degrees(){
    Acquire(mc);
	OnFwdReg(OUT_B, 22, OUT_REGMODE_SYNC);
	OnFwdReg(OUT_C, 18, OUT_REGMODE_SYNC);
	DifferentialDriveKinematic();
    Off(OUT_BC);
	Release(mc);

	Acquire(mc);
	OnRevReg(OUT_C, 40, OUT_REGMODE_SPEED);
	OnFwdReg(OUT_B, 40, OUT_REGMODE_SPEED);
	DifferentialDriveKinematic();
	DifferentialDriveKinematic();
    Off(OUT_BC);
	Release(mc);
	
}

//Função para o robo girar 90 graus no proprio eixo
void Turn90Degrees(){
    Acquire(mc);
	OnFwdReg(OUT_B, 22, OUT_REGMODE_SYNC);
	OnFwdReg(OUT_C, 18, OUT_REGMODE_SYNC);
	DifferentialDriveKinematic();
    Off(OUT_BC);
	Release(mc);

	Acquire(mc);
	OnRevReg(OUT_C, 40, OUT_REGMODE_SPEED);
	OnFwdReg(OUT_B, 40, OUT_REGMODE_SPEED);
	DifferentialDriveKinematic();
    Off(OUT_BC);
	Release(mc);
	
}

//Thread para retirar e depositar o objeto quando reconhecido
task getObject(){
	while(true){
		if(state == "Warehouse"){
			if(SensorUS(IN_4) <= OBJECT && Getted == false && SensorValue(IN_3) == 0){
				Off(OUT_BC);
				RotateMotor(OUT_A, 30, -90);
				DifferentialDriveKinematic();
				RotateMotor(OUT_A, 30, 90);
				DifferentialDriveKinematic();
				Getted = true;
				Rotate = true;
				Off(OUT_A);
				localCounter = localCounter + 2;
				DifferentialDriveKinematic();
				if(localCounter > 8){
					localCounter = 0;
		    		}
		    		localMS();
			}
		}if(state == "Download"){
			Off(OUT_BC);
			RotateMotor(OUT_A, 30, -90);
			DifferentialDriveKinematic();
			Acquire(mc);
			OnFwdReg(OUT_B, 22, OUT_REGMODE_SYNC);
			OnFwdReg(OUT_C, 18, OUT_REGMODE_SYNC);
			DifferentialDriveKinematic();
			Off(OUT_BC);
			Release(mc);
			RotateMotor(OUT_A, 30, 90);
            DifferentialDriveKinematic();
			Off(OUT_A);
			localCounter = localCounter + 1;
			DifferentialDriveKinematic();
			if(localCounter > 8){
                		localCounter = 0;
            		}
            		localMS();
        	}
        	if(state == "Recharge"){
        		Getted = false;
        		Rotate = false;
        	}
	}
}
//Thread para exibir valores no display(Debug)
task view_atributes(){
	while(true){
		TextOut(0,LCD_LINE1,"Sensor Ultrassonico:");
		NumOut(0,LCD_LINE2,SensorUS(IN_4));
		TextOut(0,LCD_LINE3,"Sensor de Luz:");
		NumOut(0, LCD_LINE4, SensorValue(IN_2));
		TextOut(0,LCD_LINE5,"Sensor de Toque:");
		NumOut(0,LCD_LINE6,SensorValue(IN_3));
		TextOut(0,LCD_LINE7,"Estado:");
		TextOut(0,LCD_LINE8,state);
		Wait(200);
		ClearScreen();
	}
}

//Thread para desviar de obstaculos
task avoid_wall(){
	while(true){
		if(SensorUS(IN_4) < WALL &&  SensorValue(IN_3) == 1){
			Off(OUT_BC);
			Acquire(mc);
			OnFwdReg(OUT_B, 22, OUT_REGMODE_SYNC);
			OnFwdReg(OUT_C, 18, OUT_REGMODE_SYNC);
			DifferentialDriveKinematic();
            Off(OUT_BC);
			Release(mc);
			Acquire(mc);
			OnRevReg(OUT_C, 18, OUT_REGMODE_SPEED);
			OnFwdReg(OUT_B, 18, OUT_REGMODE_SPEED);
			DifferentialDriveKinematic();
            Off(OUT_BC);
			Release(mc);
		}else{
			if(Rotate == true){
				Rotate = false;
				Acquire(mc);
				OnRevReg(OUT_B, 18, OUT_REGMODE_SPEED);
				OnFwdReg(OUT_C, 18, OUT_REGMODE_SPEED);
				DifferentialDriveKinematic();
                Off(OUT_BC);
				Release(mc);
				
				
			}
			Acquire(mc);
			OnRevReg(OUT_B, 22, OUT_REGMODE_SYNC);
			OnRevReg(OUT_C, 18, OUT_REGMODE_SYNC);
			Release(mc);
		
		}
	}
}

//Thread para detectar as fitas coloridas
task line_detect(){
	while(true){
		if(SensorValue(IN_2) <= BLACK){
			if(state == "Recharge" || state == "Warehouse" || state == "ExitWarehouse" || state == "Housing"){
				TurnNinetyDegreesLeftPivoting();
			}
			if(state == "Stock" || state == "SearchBase" || state == "SearchRecharge"){
				Turn90Degrees();
			}if(state == "ExitHousing"){
				Acquire(mc);
				OnFwdReg(OUT_B, 22, OUT_REGMODE_SYNC);
				OnFwdReg(OUT_C, 18, OUT_REGMODE_SYNC);
				DifferentialDriveKinematic();
                Off(OUT_BC);
			
				OnRevReg(OUT_B, 18, OUT_REGMODE_SPEED);
				OnFwdReg(OUT_C, 18, OUT_REGMODE_SPEED);
				DifferentialDriveKinematic();
                Off(OUT_BC);
				Release(mc);
				

					
			}
		}if(SensorValue(IN_2) > SILVER){
			localCounter = localCounter + 1;
			DifferentialDriveKinematic();
			if(localCounter > 8){
                		localCounter = 0;
            		}
            		localMS();
		}if(SensorValue(IN_2) > REDMIN && SensorValue(IN_2) < REDMAX){
            		if(state == "Stock" || state == "SearchBase"){
			    	TurnNinetyDegreesRightPivoting();
            		}
            		if(state == "Housing"){
            			Turn180Degrees();
            		}
		}
				
	}
}

//Main
task main(){
	SetSensorLight(IN_2);
	SetSensorUltrasonic(IN_4);
	SetSensorTouch(IN_3);
	Precedes(getObject,line_detect,avoid_wall,view_atributes);
}
				
